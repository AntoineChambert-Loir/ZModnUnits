/-
Copyright (c) 2025 Antoine Chambert-Loir. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Antoine Chambert-Loir
-/

import Mathlib.GroupTheory.SpecificGroups.Alternating.Centralizer
import Mathlib.GroupTheory.SpecificGroups.KleinFour
import Mathlib.GroupTheory.Sylow

/-! # The Klein Four subgroup of an alternating group on 4 letters

Let `α` be a finite type.

* `alternatingGroup.center_eq_bot`: when `4 ≤ Nat.card α`,
then center of `alternatingGroup α` is trivial.

We now assume that `Nat.card α = 4`.

* `alternatingGroup.kleinFour` : the subgroup
of `alternatingGroup α` generated by permutations of cycle type (2, 2).

* `alternatingGroup.kleinFour_isKleinFour`:
`alternatingGroup.kleinFour α` satisfies `IsKleinFour`.
(When `4 < Nat.card α`, it is equal to `⊤`, when `Nat.card α < 4`, it is trivial.)

* `alternatingGroup.two_sylow_eq_kleinFour_of_four`:
All `2`-sylow subgroups of `alternatingGroup α` are equal
to `kleinFour α`.

* `alternatingGroup.characteristic_kleinFour`:
the subgroup `alternatingGroup.kleinFour α` is characteristic.

* `alternatingGroup.normal_kleinFour`:
the subgroup `alternatingGroup.kleinFour α` is normal.

* `alternatingGroup.kleinFour_eq_commutator`:
the subgroup `alternatingGroup.kleinFour α` is
the commutator subgroup of `alternatingGroup α`.
(When `4 < Nat.card α`, the commutator subgroup of `alternatingGroup α` is equal to `⊤`;
when `Nat.card α < 3`, it is trivial.)

## Remark on implementation

We start from `alternatingGroup.kleinFour α` as given by its definition.
We first prove that it is equal to any 2-sylow subgroup:
the elements of such a sylow subgroup `S` have order a power of 2,
and this implies that their cycle type is () or (2,2).
Since there are exactly 4 elements of that cycle type,
we conclude that `alternatingGroup.kleinFour α = S`.
Since all 2-sylow subgroups are conjugate, we conclude
that there is only one 2-sylow subgroup and that it is normal,
and then characteristic.

## TODO :
Prove `alternatingGroup.kleinFour α = commutator (alternatingGroup α)`
without any assumption on `Nat.card α`.

-/

namespace alternatingGroup

open Equiv.Perm Equiv

variable {α : Type*} [DecidableEq α] [Fintype α]

variable (α) in
/-- The subgroup of `alternatingGroup α` generated by permutations of cycle type (2, 2).

When `Nat.card α = 4`, it will effectively be of Klein Four type. -/
def kleinFour : Subgroup (alternatingGroup α) :=
  Subgroup.closure {g : alternatingGroup α | (g : Equiv.Perm α).cycleType = {2, 2}}

theorem mem_kleinFour_of_order_two_pow (hα4 : Nat.card α = 4) {g : Perm α}
    (hg0 : g ∈ alternatingGroup α) {n : ℕ} (hg : orderOf g ∣ 2 ^ n) :
    g.cycleType = { } ∨ g.cycleType = {2, 2} := by
  rw [mem_alternatingGroup, sign_of_cycleType] at hg0
  have h1 : g.cycleType.sum ≤ 4 := by
    rw [sum_cycleType, ← hα4, Nat.card_eq_fintype_card]
    exact g.support.card_le_univ
  have h2 : ∀ k ∈ g.cycleType, k = 2 := by
    intro k hk
    have hk4 := (Multiset.le_sum_of_mem hk).trans h1
    have hk1 := one_lt_of_mem_cycleType hk
    interval_cases k
    · rfl
    · rw [← lcm_cycleType, Multiset.lcm_dvd] at hg
      exact Nat.prime_eq_prime_of_dvd_pow Nat.prime_three Nat.prime_two (hg 3 hk)
    · contrapose! hg0
      obtain ⟨t, ht⟩ := Multiset.exists_cons_of_mem hk
      rw [ht, Multiset.sum_cons, add_le_iff_nonpos_right, le_zero_iff,
        Multiset.sum_eq_zero_iff, ← Multiset.eq_replicate_card] at h1
      have h : 0 ∉ g.cycleType := Nat.not_succ_lt_self ∘ one_lt_of_mem_cycleType
      replace h : t = 0 := by simpa [h1 ▸ ht, Multiset.mem_replicate] using h
      simp [ht, h, Units.ext_iff]
  rw [← Multiset.eq_replicate_card] at h2
  rw [h2, Multiset.sum_replicate, smul_eq_mul, ← Nat.le_div_iff_mul_le two_pos] at h1
  interval_cases g.cycleType.card <;> simp [h2, Units.ext_iff] at hg0 ⊢

theorem card_of_four (hα4 : Nat.card α = 4) :
    Nat.card (alternatingGroup α) = 12 := by
  have : Nontrivial α := by
    rw [← Finite.one_lt_card_iff_nontrivial, hα4]
    norm_num
  rw [Nat.card_eq_fintype_card, card_alternatingGroup,
    ← Nat.card_eq_fintype_card, hα4]
  decide

theorem card_two_sylow_of_four (hα4 : Nat.card α = 4) (S : Sylow 2 (alternatingGroup α)) :
    Nat.card S = 4 := by
  rw [Sylow.card_eq_multiplicity, card_of_four hα4]
  have : 12 = 2 ^ 2 * 3 := by norm_num
  rw [this, Nat.factorization_mul_apply_of_coprime (by decide), Nat.factorization_pow,
    Finsupp.coe_smul, Pi.smul_apply, smul_eq_mul, Nat.prime_two.factorization_self,
    Nat.factorization_eq_zero_of_not_dvd (by decide)]
  norm_num

theorem two_sylow_carrier_of_four (hα4 : Nat.card α = 4) (S : Sylow 2 (alternatingGroup α)) :
    S.carrier =
      {g : alternatingGroup α |
        (g : Perm α).cycleType = 0 ∨ (g : Perm α).cycleType = {2, 2}} := by
  classical
  apply Set.eq_of_subset_of_card_le
  · -- inclusion S ⊆ (cycleType = 0 ∨ cycleType = { 2, 2 })
    intro k hk
    simp only [Set.mem_setOf_eq]
    obtain ⟨n, hn⟩ := (IsPGroup.iff_orderOf.mp S.isPGroup') ⟨k, hk⟩
    rw [← orderOf_submonoid ⟨k, hk⟩, Subgroup.coe_mk] at hn
    apply mem_kleinFour_of_order_two_pow hα4 k.prop
    rw [orderOf_submonoid, hn]
  -- card K4 ≤ card S
  simp only [← Nat.card_eq_fintype_card]
  change _ ≤ Nat.card S
  rw [card_two_sylow_of_four hα4 S]
  rw [Nat.card_eq_fintype_card]
  apply le_trans (Fintype.card_subtype_or _ _)
  simp only [Fintype.card_subtype]
  simp only [AlternatingGroup.card_of_cycleType, ← Nat.card_eq_fintype_card, hα4]
  decide

theorem two_sylow_eq_kleinFour_of_four (hα4 : Nat.card α = 4) (S : Sylow 2 (alternatingGroup α)) :
    S = kleinFour α := by
  have h : S = {1} ∪ {g : alternatingGroup α | (g.1).cycleType = {2, 2}} :=
    (two_sylow_carrier_of_four hα4 S).trans (by ext; simp)
  rw [kleinFour, ← Subgroup.closure_insert_one, ← Set.singleton_union, ← h]
  exact S.closure_eq.symm

theorem subsingleton_two_sylow (hα4 : Nat.card α = 4) :
    Subsingleton (Sylow 2 (alternatingGroup α)) where
  allEq S T := by
    rw [Sylow.ext_iff]
    simp [two_sylow_eq_kleinFour_of_four hα4]

theorem characteristic_kleinFour (hα4 : Nat.card α = 4) :
    (kleinFour α).Characteristic := by
  obtain ⟨S : Sylow 2 (alternatingGroup α)⟩ := Sylow.nonempty (G := alternatingGroup α)
  rw [← two_sylow_eq_kleinFour_of_four hα4 S]
  apply Sylow.characteristic_of_subsingleton
  exact subsingleton_two_sylow hα4

theorem normal_kleinFour (hα4 : Nat.card α = 4) :
    (kleinFour α).Normal := by
  have _ := characteristic_kleinFour hα4
  apply Subgroup.normal_of_characteristic

theorem kleinFour_card (hα4 : Nat.card α = 4) :
    Nat.card (kleinFour α) = 4 := by
  obtain ⟨S : Sylow 2 (alternatingGroup α)⟩ := Sylow.nonempty (G := alternatingGroup α)
  rw [← two_sylow_eq_kleinFour_of_four hα4 S, card_two_sylow_of_four hα4 S]

theorem kleinFour_carrier_eq (hα4 : Nat.card α = 4) :
    (kleinFour α).carrier =
      {g : alternatingGroup α |
        (g : Equiv.Perm α).cycleType = 0 ∨ (g : Equiv.Perm α).cycleType = {2, 2}} := by
  obtain ⟨S : Sylow 2 (alternatingGroup α)⟩ := Sylow.nonempty (G := alternatingGroup α)
  rw [← two_sylow_eq_kleinFour_of_four hα4 S, two_sylow_carrier_of_four hα4]

theorem exponent_kleinFour_of_four (hα4 : Nat.card α = 4) :
    Monoid.exponent (kleinFour α) = 2 := by
  have : Monoid.exponent (kleinFour α) ∣ 2 := by
    rw [Monoid.exponent_dvd]
    rintro ⟨⟨g, hg⟩, hg'⟩
    simp only [Subgroup.orderOf_mk, orderOf_dvd_iff_pow_eq_one]
    rw [← Subgroup.mem_carrier, kleinFour_carrier_eq hα4] at hg'
    rcases hg' with hg' | hg'
    · simp only [Equiv.Perm.cycleType_eq_zero] at hg'
      simp only [hg', one_pow]
    · convert pow_orderOf_eq_one g
      rw [← Equiv.Perm.lcm_cycleType, hg']
      norm_num
  rw [Nat.dvd_prime Nat.prime_two] at this
  apply Or.resolve_left this
  rw [Monoid.exp_eq_one_iff, ← Finite.card_le_one_iff_subsingleton,  kleinFour_card hα4]
  decide

theorem kleinFour_isKleinFour (hα4 : Nat.card α = 4) :
    IsKleinFour (kleinFour α) where
  card_four := kleinFour_card hα4
  exponent_two := exponent_kleinFour_of_four hα4

theorem kleinFour_eq_commutator (hα4 : Nat.card α = 4) :
    kleinFour α = commutator (alternatingGroup α) := by
  have _ : (kleinFour α).Normal := normal_kleinFour hα4
  have : Nat.card (alternatingGroup α ⧸ kleinFour α) = 3 := by
    rw [← Nat.mul_left_inj (a := Nat.card (kleinFour α))]
    · rw [← Subgroup.card_eq_card_quotient_mul_card_subgroup]
      rw [card_of_four hα4, kleinFour_card hα4]
    rw [kleinFour_card hα4]; norm_num
  have comm_le : commutator (alternatingGroup α) ≤ kleinFour α := by
    rw [← Subgroup.Normal.quotient_commutative_iff_commutator_le]
    exact (isCyclic_of_prime_card this).commutative
  have comm_ne_bot : commutator (alternatingGroup α) ≠ ⊥ := by
    rw [ne_eq, commutator_eq_bot_iff_center_eq_top,
      center_eq_bot (le_of_eq hα4.symm)]
    apply @bot_ne_top _ _ _ ?_
    rw [Subgroup.nontrivial_iff, ← Finite.one_lt_card_iff_nontrivial,
      card_of_four hα4]
    norm_num
  obtain ⟨k, hk, hk'⟩ := Or.resolve_left (Subgroup.bot_or_exists_ne_one _) comm_ne_bot
  suffices hk22 : (k : Equiv.Perm α).cycleType = {2, 2} by
    refine le_antisymm ?_ comm_le
    intro g hg
    rw [← Subgroup.mem_carrier, kleinFour_carrier_eq hα4] at hg
    rcases hg with hg | hg
    · rw [Equiv.Perm.cycleType_eq_zero, OneMemClass.coe_eq_one] at hg
      rw [hg]
      exact Subgroup.one_mem _
    · rw [← hg, ← Equiv.Perm.isConj_iff_cycleType_eq, isConj_iff] at hk22
      obtain ⟨c, hc⟩ := hk22
      rw [← MulAut.conjNormal_apply, Subtype.coe_inj] at hc
      simp only [commutator, ← hc]
      let fc : MulAut (alternatingGroup α) := MulAut.conjNormal c
      suffices (⊤ : Subgroup (alternatingGroup α)) =
        Subgroup.map fc.toMonoidHom (⊤ : Subgroup (alternatingGroup α)) by
        rw [this, ← Subgroup.map_commutator]
        refine Subgroup.mem_map_of_mem _ hk
      apply symm
      rw [← MonoidHom.range_eq_map]
      rw [MonoidHom.range_eq_top]
      exact MulEquiv.surjective _
  have hk2 := comm_le hk
  rw [← Subgroup.mem_carrier, kleinFour_carrier_eq hα4] at hk2
  rcases hk2 with hk2 | hk2
  · exfalso
    apply hk'
    rw [Equiv.Perm.cycleType_eq_zero] at hk2
    simp only [← Subtype.coe_inj, hk2, Subgroup.coe_one]
  · exact hk2

end alternatingGroup
